import type {
    UseMutationResult,
    UseQueryResult,
} from "@tanstack/react-query"
import { normaliseApiError } from "@/api/internal-utils/error"
import type { MutationMapper, QueryMapper } from "@/api/internal-utils/mappers"

// TODO: Make it so that callers MUST provide types for the mappers.

/**
* Centralised factory class for creating mapped Orval-generated hooks.
* Provides generic wrappers for both mutation and query hooks.
*/
export const HookFactory = {
    /**
    * Wraps an Orval-generated mutation hook with a bidirectional mapper.
    * Accepts frontend models, converts them to backend DTOs, and maps responses back.
    */
    createMappedMutationHook<
    AutogeneratedHook extends (...args: any[]) => UseMutationResult<any, any, any, any>,
    // Extract Response and Request types from the autogenerated hook.
    BackendResponse = Awaited<ReturnType<ReturnType<AutogeneratedHook>["mutateAsync"]>>,
    // Infer the shape of { data: RequestDto } and extract inner RequestDto
    InnerArg = Parameters<ReturnType<AutogeneratedHook>["mutateAsync"]>[0],
    BackendRequest = InnerArg extends { data: infer D } ? D : never,
    FrontendRequest = unknown,
    FrontendResponse = unknown
    >(
        useGeneratedHook: AutogeneratedHook,
        mapper: MutationMapper<
            FrontendRequest,
            BackendRequest,
            BackendResponse,
            FrontendResponse
        >
    ) {
        return function useMappedMutation(...args: Parameters<AutogeneratedHook>) {
            const {
                mutateAsync,
                data,
                error,
                isPending,
                isSuccess,
                mutate: _ignoredMutate,
                isError: _ignoredIsError,
                ...rest
            } = useGeneratedHook(...args)

            async function mutate(input: FrontendRequest): Promise<FrontendResponse> {
                try {
                    const dto = mapper.toRequest(input)
                    const response = await mutateAsync({ data: dto } as InnerArg)
                    return mapper.fromResponse(response)
                } catch (err) {
                    throw normaliseApiError(err)
                }
            }

            return {
                mutate,
                model: data ? mapper.fromResponse(data) : null,
                error: error ? normaliseApiError(error) : null,
                isError: !!error,
                isPending,
                isSuccess,
                ...rest,
            }
        }
    },

    /**
    * Wraps an Orval-generated query hook with a response mapper.
    * Accepts backend data, converts it into a frontend model.
    */
    createMappedQueryHook<
    AutogeneratedHook extends (...args: any[]) => UseQueryResult<any, any>,
    BackendResponse = NonNullable<UseQueryResult<any, any>["data"]>,
    FrontendResponse = unknown
    >(
        useGeneratedQuery: AutogeneratedHook,
        mapper: QueryMapper<BackendResponse, FrontendResponse>
    ) {
        return function useMappedQuery(...args: Parameters<AutogeneratedHook>) {
            const { data, error, isLoading, isError, ...rest } = useGeneratedQuery(...args)

            return {
                data: data ? mapper.fromResponse(data as BackendResponse) : null,
                error: error ? normaliseApiError(error) : null,
                isLoading,
                isError,
                ...rest
            }
        }
    }
}
